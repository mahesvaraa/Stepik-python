# Digging a Canal

Наши Роботы решили колонизировать новый остров. На острове есть реки и хорошо бы использовать баржи, для перемещения
грузов. Это будет поэкономичней, чем гонять космический корабль. Но в некоторых зонах недостаточно рек, чтобы перевозить
по ним от одного края к другому. И Роботы решили копать каналы для воды. Нам необходимо изучить карту местности и
подсчитать сколько квадратов минимум надо вырыть, чтобы образовался канал, соединяющий северную границу территории и
южную. Карта представлена, как двумерный массив, где 0 - это вода и 1 - это суша. Квадраты считаются соединёнными только
по их сторонам.

![](https://d17mnqrx9pmt3e.cloudfront.net/media/missions/media/fad59fbf7e7c4fd2aec9f518cc5365ee/digging_canal.png)

**Входные данные:** Карта местности, как список (list) списков (list), состоящих из 1 и 0.

**Выходные данные:** Минимально возможное количество квадратов, чтобы образовать канал, как целое число (int).

Примеры:

```python
checkio([[1, 1, 1, 1, 0, 1, 1],
         [1, 1, 1, 1, 0, 0, 1],
         [1, 1, 1, 1, 1, 0, 1],
         [1, 1, 0, 1, 1, 0, 1],
         [1, 1, 0, 1, 1, 1, 1],
         [1, 0, 0, 1, 1, 1, 1],
         [1, 0, 1, 1, 1, 1, 1]]) == 2
checkio([[0, 0, 0, 0, 0, 0, 0],
         [1, 1, 1, 1, 1, 1, 1],
         [1, 1, 1, 1, 1, 1, 1],
         [1, 1, 1, 1, 1, 1, 1],
         [1, 1, 0, 1, 0, 1, 1],
         [1, 0, 0, 0, 0, 0, 1],
         [0, 0, 0, 0, 0, 0, 0]]) == 3
checkio([[1, 1, 1, 1, 1, 0, 1, 1],
         [1, 0, 1, 1, 1, 0, 1, 1],
         [1, 0, 1, 0, 1, 0, 1, 0],
         [1, 0, 1, 1, 1, 0, 1, 1],
         [0, 0, 1, 1, 0, 0, 0, 0],
         [1, 0, 1, 1, 1, 1, 1, 1],
         [1, 0, 1, 1, 1, 1, 1, 1],
         [1, 1, 1, 0, 1, 1, 1, 1]]) == 2
```

**Связь с реальной жизнью:** Это смесь поиска пути в графах или объединений и оптимизационной задачи. Что может быть
полезно в навигационном ПО и для оптимизации сетей.

**Предусловия**: 0 < len(land_map) < 10
all(0 < len(row) < 10 for row in land_map)

# Solution (не моё)

```python
from bisect import insort


# Dijkstra's algorithm
# Bag is always sorted, thanks to insertion in place.
def checkio(land):
    m, n, visited = len(land), len(land[0]), set()
    bag = sorted((start, 0, i) for i, start in enumerate(land[0]))

    while bag:
        digged, x, y = bag.pop(0)
        visited.add((x, y))
        if x == m - 1:
            return digged
        for i, j in [(1, 0), (0, 1), (0, -1), (-1, 0)]:
            xn, yn = x + i, y + j
            if not (0 <= xn < m and 0 <= yn < n) or (xn, yn) in visited: continue
            insort(bag, (digged + land[xn][yn], xn, yn))


# These "asserts" using only for self-checking and not necessary for auto-testing
if __name__ == '__main__':
    print("Example:")
    print(checkio([[1, 1, 1, 1, 0, 1, 1],
                   [1, 1, 1, 1, 0, 0, 1],
                   [1, 1, 1, 1, 1, 0, 1],
                   [1, 1, 0, 1, 1, 0, 1],
                   [1, 1, 0, 1, 1, 1, 1],
                   [1, 0, 0, 1, 1, 1, 1],
                   [1, 0, 1, 1, 1, 1, 1]]))

    assert checkio([[1, 1, 1, 1, 0, 1, 1],
                    [1, 1, 1, 1, 0, 0, 1],
                    [1, 1, 1, 1, 1, 0, 1],
                    [1, 1, 0, 1, 1, 0, 1],
                    [1, 1, 0, 1, 1, 1, 1],
                    [1, 0, 0, 1, 1, 1, 1],
                    [1, 0, 1, 1, 1, 1, 1]]) == 2, "1st example"
    assert checkio([[0, 0, 0, 0, 0, 0, 0],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 0, 1, 0, 1, 1],
                    [1, 0, 0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 0, 0, 0]]) == 3, "2nd example"
    assert checkio([[1, 1, 1, 1, 1, 0, 1, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1],
                    [1, 0, 1, 0, 1, 0, 1, 0],
                    [1, 0, 1, 1, 1, 0, 1, 1],
                    [0, 0, 1, 1, 0, 0, 0, 0],
                    [1, 0, 1, 1, 1, 1, 1, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 0, 1, 1, 1, 1]]) == 2, "3rd example"
    print("Coding complete? Click 'Check' to earn cool rewards!")

```