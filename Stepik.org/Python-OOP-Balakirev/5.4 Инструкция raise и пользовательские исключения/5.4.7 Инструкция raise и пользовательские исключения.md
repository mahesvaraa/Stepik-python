# 5.4.7 Инструкция raise и пользовательские исключения

Значимый подвиг 7. Вам поручается разработать класс TupleData, элементами которого могут являются только объекты
классов: CellInteger, CellFloat и CellString.

![](https://ucarecdn.com/ad4b5d3b-d104-4c6b-9c76-2196d4494786/)

Вначале в программе нужно объявить класс `CellInteger`, `CellFloat` и `CellString`, объекты которых создаются командами:

```python
cell_1 = CellInteger(min_value, max_value)
cell_2 = CellFloat(min_value, max_value)
cell_3 = CellString(min_length, max_length)
```

где `min_value`, `max_value` - минимальное и максимальное допустимое значение в ячейке; `min_length`, `max_length` -
минимальная и максимальная допустимая длина строки в ячейке.

В каждом объекте этих классов должны формироваться локальные атрибуты с именами `_min_value`, `_max_value`
или `_min_length`, `_max_length` и соответствующими значениями.

Запись и считывание текущего значения в ячейке должно выполняться через объект-свойство (`property`) с именем:

`value` - для записи и считывания значения в ячейке (изначально возвращает значение `None`).

Если в момент записи новое значение не соответствует диапазону `[min_value; max_value] `или `[min_length; max_length]`,
то генерируется исключения командами:

```python
raise CellIntegerException('значение выходит за допустимый диапазон')  # для объектов класса CellInteger
raise CellFloatException('значение выходит за допустимый диапазон')    # для объектов класса CellFloat
raise CellStringException('длина строки выходит за допустимый диапазон')  # для объектов класса CellString
```

Все три класса исключений должны быть унаследованы от одного общего класса:

```python
CellException
```

Далее, объявите класс TupleData, объекты которого создаются командой:

```python
ld = TupleData(cell_1, ..., cell_N)
```

где `cell_1, ..., cell_N `- объекты классов `CellInteger`, `CellFloat` и `CellString` (в любом порядке и любом
количестве).

Обращение к отдельной ячейке должно выполняться с помощью оператора:

```python
value = ld[index] # считывание значения из ячейке с индексом index
ld[index] = value # запись нового значения в ячейку с индексом index
```

Индекс `index` отсчитывается с нуля (для первой ячейки) и является целым числом. Если значение `index` выходит за
диапазон `[0; число ячеек-1]`, то генерировать исключение `IndexError`.

Также с объектами класса `TupleData` должны выполняться следующие функции и операторы:

```python
res = len(ld) # возвращает общее число элементов (ячеек) в объекте ld
for d in ld:  # перебирает значения ячеек объекта ld (значения, а не объекты ячеек)
    print(d)
```

Все эти классы в программе можно использовать следующим образом:

```python
ld = TupleData(CellInteger(0, 10), CellInteger(11, 20), CellFloat(-10, 10), CellString(1, 100))

try:
    ld[0] = 1
    ld[1] = 20
    ld[2] = -5.6
    ld[3] = "Python ООП"
except CellIntegerException as e:
    print(e)
except CellFloatException as e:
    print(e)
except CellStringException as e:
    print(e)
except CellException:
    print("Ошибка при обращении к ячейке")
except Exception:
    print("Общая ошибка при работе с объектом TupleData")
```

P.S. Данная программа должна быть выполнена штатно, без ошибок. На экран отображать ничего не нужно.

# Solution

```python
class TupleData(list):
    def __init__(self, *args):
        super().__init__(args)

    def __new__(cls, *args):
        return super().__new__(cls, args)

    def __iter__(self):
        return map(lambda i: i.value if isinstance(i, Cell) else i, super().__iter__())


class Cell:
    def __init__(self, min_val, max_val):
        self._min_length, self._max_length = min_val, max_val
        self._min_value, self._max_value = min_val, max_val
        self._value = None

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        if type(self) == CellInteger and not self._min_value <= value <= self._max_value:
            raise CellIntegerException('значение выходит за допустимый диапазон')
        elif type(self) == CellFloat and not self._min_value <= value <= self._max_value:
            raise CellFloatException('значение выходит за допустимый диапазон')
        elif type(self) == CellString and not self._min_length <= len(value) <= self._max_length:
            raise CellStringException('длина строки выходит за допустимый диапазон')
        self._value = value


class CellString(Cell): '''String'''
class CellInteger(Cell): '''Integer'''
class CellFloat(Cell): '''Float'''
class CellException(Exception): ''''''
class CellIntegerException(CellException): ''''''
class CellFloatException(CellException): ''''''
class CellStringException(CellException): ''''''


ld = TupleData(CellInteger(0, 10), CellInteger(11, 20), CellFloat(-10, 10), CellString(1, 100))

try:
    ld[0] = 1
    ld[1] = 20
    ld[2] = -5.6
    ld[3] = "Python ООП"
except CellIntegerException as e:
    print(e)
except CellFloatException as e:
    print(e)
except CellStringException as e:
    print(e)
except CellException:
    print("Ошибка при обращении к ячейке")
except Exception:
    print("Общая ошибка при работе с объектом TupleData")
```