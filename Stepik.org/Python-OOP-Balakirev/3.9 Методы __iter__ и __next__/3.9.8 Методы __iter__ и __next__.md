# 3.9.8 Методы __iter__ и __next__

Подвиг 8. Вы несколько раз уже делали стек-подобную структуру, когда объекты последовательно связаны между собой:

![](https://ucarecdn.com/87348336-e215-411b-8c2b-b08eb1fdaabd/)

Доведем ее функционал до конца. Для этого, по прежнему, нужно объявить классы:

`Stack` - для представления стека в целом;
`StackObj` - для представления отдельных объектов стека.

В классе `Stack` должны быть методы:

`push_back(obj)` - для добавления нового объекта `obj` в конец стека;
`push_front(obj)` - для добавления нового объекта `obj` в начало стека.

В каждом объекте класса `Stack` должен быть публичный атрибут:

`top` - ссылка на первый объект стека (при пустом стеке `top = None`).

Объекты класса `StackObj` создаются командой:

```python
obj = StackObj(data)
```

где `data` - данные, хранящиеся в объекте стека (строка).

Также в каждом объекте класса `StackObj` должны быть публичные атрибуты:

`data` - ссылка на данные объекта;
`next` - ссылка на следующий объект стека (если его нет, то `next = None`).

Наконец, с объектами класса `Stack` должны выполняться следующие команды:

```python
st = Stack()

st[indx] = value  # замена прежних данных на новые по порядковому индексу (indx); отсчет начинается с нуля
data = st[indx]  # получение данных из объекта стека по индексу
n = len(st)  # получение общего числа объектов стека

for obj in st:  # перебор объектов стека (с начала и до конца)
    print(obj.data)  # отображение данных в консоль
```

При работе с индексами (`indx`), нужно проверять их корректность. Должно быть целое число от `0` до `N-1`, где `N` -
число объектов в стеке. Иначе, генерировать исключение командой:

```python
raise IndexError('неверный индекс')
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

# Solution

```python
class StackObj:

    def __init__(self, data):
        self.data = data
        self.next = None

    def __repr__(self):
        return str(self.data)


class Stack:

    def __init__(self):
        self.top = None
        self.last = None

    def push_back(self, obj):
        if not self.top:
            self.top = obj
        else:
            self.last.next = obj
        self.last = obj

    def push_front(self, obj):
        if self.top:
            obj.next, self.top = self.top, obj
        else:
            self.last = self.top = obj

    def __iter__(self):
        h = self.top
        while h:
            yield h
            h = h.next

    def __len__(self):
        return sum(1 for _ in self)

    def _get_obj(self, idx):
        if idx not in range(0, len(self)):
            raise IndexError('неверный индекс')
        for i, obj in enumerate(self):
            if i == idx:
                return obj

    def __getitem__(self, idx):
        return self._get_obj(idx).data

    def __setitem__(self, idx, value):
        self._get_obj(idx).data = value

```