Index: Всякое/Тестовый файл.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>def sort_me(courses):\r\n    return sorted(courses, key=lambda x: (int(x.split('-')[1]), x.split('-')[0], len(x.split('-')[0])))\r\n\r\n\r\nprint(sort_me(['aeb-1305', 'site-1305', 'play-1215', 'web-1304', 'site-1304', 'beb-1305']))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Всякое/Тестовый файл.py b/Всякое/Тестовый файл.py
--- a/Всякое/Тестовый файл.py	(revision e41a05b77754cb5d72a5e74f45adc406c05540bd)
+++ b/Всякое/Тестовый файл.py	(date 1660200424185)
@@ -1,5 +1,17 @@
-def sort_me(courses):
-    return sorted(courses, key=lambda x: (int(x.split('-')[1]), x.split('-')[0], len(x.split('-')[0])))
+class PolyLine:
+
+    def __init__(self, *args):
+        self.start_coord, self.coords = args[0], list(args)
+
+    def add_coord(self, x, y):
+        self.coords.append((x, y))
+
+    def remove_coords(self, idx):
+        self.coords.pop(idx)
 
+    def get_coords(self):
+        return self.coords
 
-print(sort_me(['aeb-1305', 'site-1305', 'play-1215', 'web-1304', 'site-1304', 'beb-1305']))
+
+poly = PolyLine((1, 2), (3, 5), (0, 10), (-1, 8))
+print(poly.get_coords())
\ No newline at end of file
Index: CodeWars.com/6 kyu/Message Validator.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CodeWars.com/6 kyu/Message Validator.md b/CodeWars.com/6 kyu/Message Validator.md
new file mode 100644
--- /dev/null	(date 1659093180983)
+++ b/CodeWars.com/6 kyu/Message Validator.md	(date 1659093180983)
@@ -0,0 +1,24 @@
+# Message Validator
+
+https://www.codewars.com/kata/5fc7d2d2682ff3000e1a3fbc
+
+In this kata, you have an input string and you should check whether it is a valid message. To decide that, you need to split the string by the numbers, and then compare the numbers with the number of characters in the following substring.
+
+For example "`3hey5hello2hi`" should be split into 3, hey, 5, hello, 2, hi and the function should return `true`, because "hey" is 3 characters, "hello" is 5, and "hi" is 2; as the numbers and the character counts match, the result is true.
+
+**Notes:**
+
+* Messages are composed of only letters and digits
+* Numbers may have multiple digits: e.g. "`4code13hellocodewars`" is a valid message
+* Every number must match the number of character in the following substring, otherwise the message is invalid: e.g. "hello5" and "2hi2" are invalid
+* If the message is an empty string, you should return `true`
+
+# Solution
+```
+import re
+
+def is_a_valid_message(message):
+    x = re.split('\d+', message)[1:]
+    y = re.findall('\d+', message)
+    return all(map(lambda x: len(x[0]) == int(x[1]), zip(x, y)))
+```
\ No newline at end of file
Index: CodeWars.com/6 kyu/Tribonacci Sequence.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CodeWars.com/6 kyu/Tribonacci Sequence.md b/CodeWars.com/6 kyu/Tribonacci Sequence.md
new file mode 100644
--- /dev/null	(date 1659093653826)
+++ b/CodeWars.com/6 kyu/Tribonacci Sequence.md	(date 1659093653826)
@@ -0,0 +1,25 @@
+# Tribonacci Sequence
+
+Well met with Fibonacci bigger brother, AKA Tribonacci.
+
+As the name may already reveal, it works basically like a Fibonacci, but summing the last 3 (instead of 2) numbers of the sequence to generate the next. And, worse part of it, regrettably I won't get to hear non-native Italian speakers trying to pronounce it :(
+
+So, if we are to start our Tribonacci sequence with [1, 1, 1] as a starting input (AKA signature), we have this sequence:
+```
+[1, 1 ,1, 3, 5, 9, 17, 31, ...]
+```
+But what if we started with [0, 0, 1] as a signature? As starting with [0, 1] instead of [1, 1] basically shifts the common Fibonacci sequence by once place, you may be tempted to think that we would get the same sequence shifted by 2 places, but that is not the case and we would get:
+```
+[0, 0, 1, 1, 2, 4, 7, 13, 24, ...]
+```
+Well, you may have guessed it by now, but to be clear: you need to create a fibonacci function that given a signature array/list, returns the first n elements - signature included of the so seeded sequence.
+
+Signature will always contain 3 numbers; n will always be a non-negative number; if n == 0, then return an empty array (except in C return NULL) and be ready for anything else which is not clearly specified ;)
+
+# Solution
+```python
+def tribonacci(signature, n):
+    res = signature[:n]
+    for i in range(n - 3): res.append(sum(res[-3:]))
+    return res
+```
\ No newline at end of file
Index: CodeWars.com/6 kyu/Persistent Bugger.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CodeWars.com/6 kyu/Persistent Bugger.md b/CodeWars.com/6 kyu/Persistent Bugger.md
new file mode 100644
--- /dev/null	(date 1659095010119)
+++ b/CodeWars.com/6 kyu/Persistent Bugger.md	(date 1659095010119)
@@ -0,0 +1,23 @@
+# Persistent Bugger.
+
+https://www.codewars.com/kata/55bf01e5a717a0d57e0000ec
+
+Write a function, persistence, that takes in a positive parameter num and returns its multiplicative persistence, which is the number of times you must multiply the digits in num until you reach a single digit.
+
+For example (Input --> Output):
+```
+39 --> 3 (because 3*9 = 27, 2*7 = 14, 1*4 = 4 and 4 has only one digit)
+999 --> 4 (because 9*9*9 = 729, 7*2*9 = 126, 1*2*6 = 12, and finally 1*2 = 2)
+4 --> 0 (because 4 is already a one-digit number)
+```
+
+# Solution
+```python
+from functools import reduce
+def persistence(n):
+    cnt = 0
+    while len(str(n)) > 1:
+        n = str(reduce(lambda x, y: int(x) * int(y), str(n)))
+        cnt += 1
+    return cnt
+```
\ No newline at end of file
Index: CodeWars.com/6 kyu/Odd Magic Square.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CodeWars.com/6 kyu/Odd Magic Square.md b/CodeWars.com/6 kyu/Odd Magic Square.md
new file mode 100644
--- /dev/null	(date 1659100930659)
+++ b/CodeWars.com/6 kyu/Odd Magic Square.md	(date 1659100930659)
@@ -0,0 +1,44 @@
+# Odd Magic Square
+
+https://www.codewars.com/kata/570b69d96731d4cf9c001597
+
+
+Your task is to create a magic square for any positive odd integer N. The magic square contains the integers from 1 to N * N, arranged in an NxN matrix, such that the columns, rows and both main diagonals add up to the same number.
+
+Note: use have to use the Siamese method for this task.
+
+Examples:
+```python
+n = 3
+result = [
+  [8, 1, 6],
+  [3, 5, 7],
+  [4, 9, 2]
+]
+
+```
+```python
+n = 5
+result = [
+  [17, 24,  1,  8, 15],
+  [23,  5,  7, 14, 16],
+  [ 4,  6, 13, 20, 22],
+  [10, 12, 19, 21,  3],
+  [11, 18, 25,  2,  9]
+]
+```
+
+# Solution
+```python
+from math import floor
+from itertools import chain
+def magic_square(n):
+    x = [[0 for i in range(n)] for j in range(n)]
+    z, i, j = 1, 0, floor(n / 2)
+    while 0 in chain(*x):
+        if x[i % n][j % n] != 0:
+            i, j = i + 2, j - 1
+        x[i % n][j % n] = z
+        z, i, j = z + 1, i - 1, j + 1
+    return x
+```
\ No newline at end of file
Index: CodeWars.com/6 kyu/Word a10n (abbreviation).md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CodeWars.com/6 kyu/Word a10n (abbreviation).md b/CodeWars.com/6 kyu/Word a10n (abbreviation).md
new file mode 100644
--- /dev/null	(date 1659103323683)
+++ b/CodeWars.com/6 kyu/Word a10n (abbreviation).md	(date 1659103323683)
@@ -0,0 +1,33 @@
+# Word a10n (abbreviation)
+
+https://www.codewars.com/kata/5375f921003bf62192000746
+
+The word i18n is a common abbreviation of internationalization in the developer community, used instead of typing the whole word and trying to spell it correctly. Similarly, a11y is an abbreviation of accessibility.
+
+Write a function that takes a string and turns any and all "words" (see below) within that string of length 4 or greater into an abbreviation, following these rules:
+
+* A "word" is a sequence of alphabetical characters. By this definition, any other character like a space or hyphen (eg. "elephant-ride") will split up a series of letters into two words (eg. "elephant" and "ride").
+* The abbreviated version of the word should have the first letter, then the number of removed characters, then the last letter (eg. "elephant ride" => "e6t r2e").
+
+**Example**
+```python
+abbreviate("elephant-rides are really fun!")
+//          ^^^^^^^^*^^^^^*^^^*^^^^^^*^^^*
+// words (^):   "elephant" "rides" "are" "really" "fun"
+//                123456     123     1     1234     1
+// ignore short words:               X              X
+
+// abbreviate:    "e6t"     "r3s"  "are"  "r4y"   "fun"
+// all non-word characters (*) remain in place
+//                     "-"      " "    " "     " "     "!"
+=== "e6t-r3s are r4y fun!"
+```
+
+# Solution
+```python
+def abbreviate(s):
+    x = [i if i.isalpha() else '|' + i + '|' for i in s]
+    y = ''.join(x).split('|')
+    res = [(i, i[0] + str(len(i[1:-1])) + i[-1])[len(i) > 3] if i.isalpha() else i for i in y]
+    return ''.join(res)
+```
\ No newline at end of file
Index: CodeWars.com/6 kyu/Schrödinger's Boolean.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CodeWars.com/6 kyu/Schrödinger's Boolean.md b/CodeWars.com/6 kyu/Schrödinger's Boolean.md
new file mode 100644
--- /dev/null	(date 1659020092044)
+++ b/CodeWars.com/6 kyu/Schrödinger's Boolean.md	(date 1659020092044)
@@ -0,0 +1,16 @@
+# Schrödinger's Boolean
+
+Can a value be both True and False?
+
+Define omnibool so that it returns True for the following:
+```
+omnibool == True and omnibool == False
+```
+
+# Solution
+```
+class omn:
+    def __eq__(self, other):
+        return True
+omnibool = omn()
+```
\ No newline at end of file
