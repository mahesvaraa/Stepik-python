# 4.4.6 Наследование. Атрибуты private и protected

Подвиг 6. Объявите класс `Furniture` (мебель), объекты которого создаются командой:

```python
f = Furniture(name, weight)
```

где `name` - название предмета (строка); `weight` - вес предмета (целое или вещественное число).

В каждом объекте класса Furniture должны создаваться защищенные локальные атрибуты с именами `_name` и `_weight`. В
самом классе `Furniture` нужно объявить приватные методы:

`__verify_name()` - для проверки корректности имени;
`__verify_weight()` - для проверки корректности веса.

Метод `__verify_name()` проверяет, что имя должно быть строкой, если это не так, то генерируется исключение командой:

```python
raise TypeError('название должно быть строкой')
```

Метод `__verify_weight()` проверяет, что вес должен быть положительным числом (строго больше нуля), если это не так, то
генерируется исключение командой:

```python
raise TypeError('вес должен быть положительным числом')
```

Данные методы следует вызывать всякий раз при записи новых значений в атрибуты `_name` и `_weight` (а также при их
создании).

На основе базового класса `Furniture` объявить следующие дочерние классы:

`Closet` - для представления шкафов;
`Chair` - для представления стульев;
`Table` - для представления столов.

Объекты этих классов должны создаваться командами:

```python
obj = Closet(name, weight, tp, doors)  # tp: True - шкаф-купе; False - обычный шкаф; doors - число дверей (целое число)
obj = Chair(name, weight, height)  # height - высота стула (любое положительное число)
obj = Table(name, weight, height,
            square)  # height - высота стола; square - площадь поверхности (любые положительные числа)
```

В каждом объекте этих классов должны создаваться соответствующие защищенные атрибуты:

- в объектах класса `Closet`: `_name, _weight, _tp, _doors`
- в объектах класса `Chair`: `_name, _weight, _height`
- в объектах класса `Table`: `_name, _weight, _height, _square`

В каждом классе (`Closet`, `Chair`, `Table`) объявить метод:

```python
get_attrs()
```

который возвращает кортеж из значений локальных защищенных атрибутов объектов этих классов.

Пример использования классов (эти строчки в программе писать не нужно):

```python
cl = Closet('шкаф-купе', 342.56, True, 3)
chair = Chair('стул', 14, 55.6)
tb = Table('стол', 34.5, 75, 10)
print(tb.get_attrs())
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

# Solution

```python
class Furniture:

    def __init__(self, *args):
        name, weight = args
        self._name = self.__verify_name(name)
        self._weight = self.__verify_weight(weight)

    def __setattr__(self, key, item):
        self.__dict__[key] = self.__verify_name(item) if key == '_name' else self.__verify_weight(item)

    def get_attrs(self):
        return self.__dict__.values()

    def __verify_name(self, val):
        if not isinstance(val, str):
            raise TypeError('название должно быть строкой')
        return val

    def __verify_weight(self, val):
        if not isinstance(val, (float, int)) and not val > 0:
            raise TypeError('название должно быть строкой')
        return val


class Closet(Furniture):

    def __init__(self, name, weight, tp, doors):
        super().__init__(name, weight)
        self._tp, self._doors = tp, doors


class Chair(Furniture):

    def __init__(self, name, weight, height):
        super().__init__(name, weight)
        self._height = height


class Table(Furniture):

    def __init__(self, name, weight, height, square):
        super().__init__(name, weight)
        self._height, self._square = height, square
```