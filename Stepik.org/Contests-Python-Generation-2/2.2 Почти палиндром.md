# Почти палиндром

Назовем строку текста «почти палиндромом», если найдется такой буквенный символ, при удалении которого строка станет
палиндромом. При этом все символы, кроме букв, должны игнорироваться.

Напишите программу, которая определяет, является ли строка «почти палиндромом».

**Формат входных данных**
На вход программе подается строка текста, состоящая только из букв латинского алфавита в нижнем регистре, цифр и
символов !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~. Длина строки не превышает 300000300000 символов. Гарантируется, что строка
содержит как минимум две буквы.

**Формат выходных данных**
Программа должна вывести `True`, если введенная строка является «почти палиндромом», или `False` в противном случае.

**Примечание 1.** Палиндром читается одинаково в обоих направлениях, например слово «rotavator».

**Примечание 2**. Посмотреть все тесты к задаче можно по ссылке.

**Sample Input 1:**

```
1kilg%rli8k
```

**Sample Output 1:**

```
True
```

**Sample Input 2:**

```
kkkkkkkkkee
```

**Sample Output 2:**

```
False
```

**Sample Input 3:**

```
#14&*@(a)!(@14112)!@$)!@*$!*a)$*099
```

**Sample Output 3:**

```
True
```

**Sample Input 4:**

```
ekkkkkkkkkkkkkkkkkkkkkk
```

**Sample Output 4:**

```
True
```

# Solution

```python
simbols = """!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~0123456789"""
a = input()
c = a[::-1]
b = a
for i in simbols:
    a = a.replace(i, '')
if len(set(a)) == 1:
    print(True)
elif len(set(a[:len(a) // 2 + 1])) - len(set(a[len(a) // 2:])) not in [-1, 0, 1]:
    print(False)
else:
    for k, v in enumerate(a):
        if a[:k] + a[k + 1:] == (a[:k] + a[k + 1:])[::-1]:
            print(True)
            break
        if c[:k] + c[k + 1:] == (c[:k] + c[k + 1:])[::-1]:
            print(True)
            break
    else:
        print(False)
```